datahora:
from datetime import date
from datetime import datetime, timedelta, timezone

data_atual = date.today()
print(data_atual) # Saida padrao

data_em_texto = '{}/{}/{}'.format(data_atual.day, data_atual.month, data_atual.year)
print(data_em_texto) # Substituição do traço por / e ordem dos elementos dd mm AAAA

data_em_texto = data_atual.strftime('%d/%m/%Y')
print(data_em_texto) # Saida formatada com dois digitos para dia e mes

data_e_hora_atuais = datetime.now() # Usando datetime no lugar de date
data_e_hora_em_texto = data_e_hora_atuais.strftime('%d/%m/%Y')
print(data_e_hora_em_texto)

data_e_hora_em_texto = data_e_hora_atuais.strftime('%d/%m/%Y %H:%M')
print(data_e_hora_em_texto) # Saida com data e hora

diferenca = timedelta(hours=-3) # Como indicar o timezone?
print(diferenca)
fuso_horario = timezone(diferenca)
print(fuso_horario) # UTC -3 horas

------------------------------------------------------------------------------------------------
escopo:

def func1(x):
    x = 10
    print(f'Função func1 - x = {x}')


def func2(x):
    x = 20
    print(f'Função func2 - x = {x}')


x = 0
func1(x)
func2(x)
print(f'Programa principal - x = {x}')

''' Saidas:
Função func1 - x = 10
Função func2 - x = 20
Programa principal - x = 0
'''

------------------------------------------------------------------------------------------------
escopo 2:
def func1():
    global x
    x = 10
    print(f'Função func1 - x = {x}')


def func2():
    global x
    x = 20
    print(f'Função func2 - x = {x}')


x = 0
func1()
func2()
print(f'Programa principal - x = {x}')

''' Saida:
Função func1 - x = 10
Função func2 - x = 20
Programa principal - x = 20
'''
------------------------------------------------------------------------------------------------
taximetro:

''' Nesta funcao, o parâmetro multiplicador da função taximetro tem um 
    valor padrão igual a 1. Isso significa que, se não passarmos um valor
    para multiplicador ao chamar a função, ele usará 1 como padrão.
'''
def taximetro(distancia, multiplicador=1):
    largada = 3
    km_rodado = 2
    valor = (largada + distancia * 
    km_rodado) * multiplicador
    return valor # retorna uma valor

pagamento = taximetro(3.5)
print(pagamento) # saida: 10.0

''' Atividade:
    Qual mudança você faria neste código para cobrar uma taxa mínima no
    aplicativo (distancia=1) quando o usuário cancelasse a chamada do
    após 5 minutos do pedido aceito pelo motorista

    Dica: Pesquise sobre o uso das bibliotecas datetime e pytz
'''

------------------------------------------------------------------------------------------------
from random import randint


def cpf_validate(numbers):
    #  Obtém os números do CPF e ignora outros caracteres
    cpf = [int(char) for char in numbers if char.isdigit()]

    #  Verifica se o CPF tem 11 dígitos
    if len(cpf) != 11:
        return False

    #  Verifica se o CPF tem todos os números iguais, ex: 111.111.111-11
    #  Esses CPFs são considerados inválidos mas passam na validação dos dígitos
    #  Antigo código para referência: if all(cpf[i] == cpf[i+1] for i in range (0, len(cpf)-1))
    if cpf == cpf[::-1]:
        return False

    #  Valida os dois dígitos verificadores
    for i in range(9, 11):
        value = sum((cpf[num] * ((i+1) - num) for num in range(0, i)))
        digit = ((value * 10) % 11) % 10
        if digit != cpf[i]:
            return False
    return True


def cpf_generate():
    #  Gera os primeiros nove dígitos (e certifica-se de que não são todos iguais)
    while True:
        cpf = [randint(0, 9) for i in range(9)]
        if cpf != cpf[::-1]:
            break

    #  Gera os dois dígitos verificadores
    for i in range(9, 11):
        value = sum((cpf[num] * ((i + 1) - num) for num in range(0, i)))
        digit = ((value * 10) % 11) % 10
        cpf.append(digit)

    #  Retorna o CPF como string
    result = ''.join(map(str, cpf))
    return result


opcao = int(input('''[1] Validar um CPF
[2] Gerar um CPF válido
Opção: '''))
if opcao == 1:
    cpf = input('Digite o CPF: ')
    if cpf_validate(cpf):
        print('CPF válido.')
    else:
        print('CPF inválido.')
elif opcao == 2:
    cpf = cpf_generate()
    if cpf_validate(cpf):
        print(f'CPF gerado: {cpf[:3]}.{cpf[3:6]}.{cpf[6:9]}-{cpf[9:]}')
else:
    print('Inválido.')
------------------------------------------------------------------------------------------------
